{"name":"HLTV Scorebot","tagline":"Node.js and Browser implementation of the HLTV.ORG-Scorebot.","body":"## Getting started\r\n\r\n**Get the module with the npm:**\r\n```\r\nnpm install hltv-scorebot\r\n```\r\n\r\n**Install manually:**\r\n\r\n1. Download the latest build of the module at [Releases](https://github.com/Nols1000/hltv-scorebot/releases).\r\n2. Extract the package and copy it to your projects `node_modules`-folder\r\n3. Rename the module-folder (e.g. `hltv-scorebot-0.1.4`) to `hltv-scorebot`\r\n4. Execute your console in the module-folder (`hltv-scorebot`)\r\n5. Execute `npm install` (This should download and install all dependencies [currently only `socket.io-client@1.3.5`. Check out `package.json`]) \r\n\r\n**Using HLTV-Scorebot:**\r\n```javascript\r\nvar Scorebot = require('hltv-scorebot');\r\n\r\nvar sb = new Scorebot();\r\n    sb.connect('http://scorebot.hltv.org', 10023, 36747)  // Match 36747 was CLG vs eBettle at ESL One Cologne 2015\r\n                                                          // Check out the helper-branch for example data\r\n    sb.on('kill', function(killer, victim, weapon, headshot, assister) {\r\n        \r\n        var killerName = killer.name;\r\n        \r\n        // Checking if assister exists\r\n        if(assister)\r\n            killerName = killer.name + \" and \" + assister.name;  \r\n        \r\n        console.log(killer.name, 'killed', vicitim.name, 'with', weapon, headshot ? 'headshot' : '');\r\n    });\r\n```\r\n\r\n## Constants\r\n\r\n- ### Team\r\n  - `TERRORIST = 0`\r\n  - `COUNTERTERRORIST = 1`\r\n\r\n## Methods\r\n\r\n- `connect(url, port, matchid)`\r\n    - `url` the ip of the scorebot server (def. `http://scorebot.hltv.org`).\r\n    - `port` the port of the scorebot server (def. `10023`).\r\n    - `matchid` identifier for your wanted match. [andrewda](https://github.com/andrewda) made a module to get the matchid <https://github.com/andrewda/hltv-live-games>\r\n- `on(event, callback)`\r\n    - `event`\r\n       - `time`\r\n          - `callback: function(time) [int]`\r\n          - updates game clock every second \r\n          - freeze timer is **experimental**\r\n       - `score`\r\n          - `callback: function(tscore, ctscore) [int, int]`\r\n          - updates score every round after `roundend`\r\n       - `player`\r\n          - `callback: function(playermanager) [PlayerManager]`\r\n          - updates playermanager every time a player is updated\r\n       - `kill`\r\n          - `callback: function(killer, victim, weapon, headshot, assister) [Player, Player, String, boolean, Player]`\r\n          - triggers callback when `killer` kills `victim` with `weapon`\r\n          - assister is **optional**\r\n       - `assist`\r\n          - `callback: function(assister, victim) [Player, Player]`\r\n          - triggers callback when `assister` assists in a kill of `victim`\r\n       - `bombplanted`\r\n          - `callback: function(planter) [Player]`\r\n          - triggers callback when bomb is planted\r\n       - `bombdefused`\r\n          - `callback: function(defuser) [Player]`\r\n          - triggers callback when bomb is defused\r\n       - `roundstart`\r\n          - `callback: function()`\r\n          - triggers callback when round starts\r\n       - `roundend`\r\n          - `callback: function(winner, tscore, ctscore) [int, int, int]`\r\n          - triggers callback when round ends\r\n          - `winner` 0 | 1 (0 - T | 1 - CT)\r\n       - `playerjoin`\r\n          - `callback: function(player) [Player]`\r\n          - triggers callback when a player joins the server\r\n       - `playerquit`\r\n          - `callback: function(player) [Player]`\r\n          - triggers callback when a player leaves the server\r\n       - `mapchange`\r\n          - `callback: function(map) [String]`\r\n          - triggers callback when the server changes map\r\n       - `restart`\r\n          - `callback: function()`\r\n          - triggers callback when server restarts\r\n\r\n## Classes\r\n\r\n- `Scorebot.Player`\r\n  - `id [int]`\r\n  - `steamID [String]`\r\n  - `name [String]`\r\n  - `team [int]`\r\n  - `kills [int] `\r\n  - `assists [int]`\r\n  - `deaths [int]`\r\n  - `alive [boolean]`\r\n- `Scorebot.HLTVPlayer`\r\n  - `name [String]`\r\n  - `team [int]`\r\n  - `kills [int] `\r\n  - `deaths [int]`\r\n  - `alive [boolean]`\r\n- `Scorebot.KPlayer`\r\n  - `id [int]`\r\n  - `steamID [String]`\r\n  - `name [String]`\r\n  - `team [int]`\r\n- `Scorebot.APlayer`\r\n  - `id [int]`\r\n  - `name [String]`\r\n  - `team [int]`\r\n  - NODE: Assist will be counted when merge with `Player`\r\n- `Scorebot.PlayerManager`\r\n  - `TERRORIST [int]`\r\n    - 0\r\n  - `COUNTERTERRORIST [int]`\r\n    - 1\r\n  - `playerList[team][index] [Array]`\r\n    - 2 dimensional array\r\n    - stores all players\r\n  - `set(team, player) [function]`\r\n    - append/update player `player` in team `team`\r\n  - `get(team, index) [function]`\r\n    - returns the player in team `team` at `index`\r\n  - `getIndex(name) [function]`\r\n    - returns object with team and index of the player with the name `name`\r\n    - return: `{ 'team': 0, 'index': 0 }`\r\n    - returns `{ 'team': -1, 'index': -1 }` if there is no player with the name `name`\r\n  - `getByName(name) [function]`\r\n    - returns player with the name `name`\r\n  - `getByNameAsync(name, callback) [function]`\r\n    - calls the callback with player with the name `name` as argument\r\n    - callback: `function(error, player)`\r\n  - `del(name) [function]`\r\n    - deletes player with the name `name`\r\n\r\n\r\n## Known Bugs\r\n\r\n- Assists counter wont reset after warm-up\r\n\r\n## Examples\r\n\r\nTo be done \r\n\r\n**(Try the examples Folder at the [hltv-scorebot repository](https://github.com/Nols1000/hltv-scorebot))**\r\n\r\n---\r\n\r\nI'm sorry for my poor English. If you have some problems understanding the module, the README or my documentation please mail me (nilsmargotti [at] gmail [dot] com).\r\n\r\nEvery Feedback is welcome.\r\n\r\n*Nils 'Nols1000' Margotti*\r\n","google":"UA-44437967-4","note":"Don't delete this file! It's used internally to help with page regeneration."}